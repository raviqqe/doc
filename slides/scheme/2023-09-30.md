# Hygienic macro on Stak Scheme

[@raviqqe](https://github.com/raviqqe)

September 30, 2023

---

# Contents

- Hygienic macro
  - Overview
  - Implementation
- Progress
  - New features
  - Next tasks...

---

# Hygienic macro

---

# Overview

- Macros transcribes a source code into another source code.
- Hygienic macros must not:
  - Insert a binding that captures a reference not introduced by the macro itself.
  - Insert a reference that is captured by a binding not introduced by the macro itself.

---

# Examples

## Capturing a reference not introduced by the macro

### Definition

```scheme
(define x 42)

(define-syntax foo
  (syntax-rules
    ((foo)
      x)))
```

```scheme
(let ((x 13))
  (foo)) ; -> x == 13
```

---

# Examples

## Captured by a binding not introduced by the macro

### Definition

```scheme
(define-syntax foo
  (syntax-rules
    ((foo x)
      ((lambda (y) x) 13))))
```

```scheme
(define y 42)

(foo y) ; -> ((lambda (y) y) 13) == 13
```

---

# Implementation

- Based on [Macros That Work by William Clinger][macros-that-work]
- With modifications for:
  - Global variables
  - Destructive update of syntactic environment

## What to do?

- Track syntactic environment
  - What do variables denote on definitions and uses of macros?
- Expanding macros while preserving the hygienic invariants
  - Renaming variables introduced by macros

---

# Implementation

## Representation of syntactic environment

- The `environment` field is an association list from symbols to their denotations.

```scheme
(define-record-type expansion-context
  (make-expansion-context environment)
  expansion-context?
  (environment expansion-context-environment expansion-context-set-environment!))
```

---

# Implementation

## Expanding macros

- Rename free variables introduced by macros.
- Keep denotations on the use of macros.

```scheme
(define (fill-template definition-context use-context matches template)
  (cond
    ((symbol? template)
      (let ((pair (assv template matches)))
        (if pair
          (cdr pair)
          (let (
              (name (rename-variable use-context template))
              (denotation (resolve-denotation definition-context template)))
            (when (denotation? denotation)
              (expansion-context-set! use-context name (denotation-value denotation)))
            name))))

    ; ...
```

---

## Stak Scheme

- It had only the "poisonous" `syntax-rules` macro.
- Now, it's hygienic!
  - ~300 lines in total
    - Including comments and blank lines
    - `syntax-rules` pattern match
    - Hygienic macro definition and expansion

---

## References

- [BiwaSchemeにhygienic macroを入れる | 定期ミートアップ 第7回 yhara](https://scrapbox.io/prog-lang-sys-ja/%E5%AE%9A%E6%9C%9F%E3%83%9F%E3%83%BC%E3%83%88%E3%82%A2%E3%83%83%E3%83%97_%E7%AC%AC7%E5%9B%9E_yhara)
- [Macros That Work (a paper)][macros-that-work]
- [Hygienic Macros Through Explicit Renaming](https://dl.acm.org/doi/pdf/10.1145/1317265.1317269)
- [5.2 Hygienic macros | Gauche](https://practical-scheme.net/gauche/man/gauche-refe/Hygienic-macros.html)
- [Hygienic macro | Wikipedia](https://en.wikipedia.org/wiki/Hygienic_macro)

---

# Progress

---

# Other new features

- Hygienic `syntax-rules`
- Quasi-quotation
- `read` and `write` procedures
- Symbol table GC
- Ports and EOF objects

---

# Next tasks...

- `apply` procedure
  - [Ribbit Scheme][ribbit] implemented it as a primitive.
- Record type
- `cond-expand`
- Self-hosting

---

# Summary

- Building Scheme is fun (again.)

[ribbit]: https://github.com/udem-dlteam/ribbit/tree/main
[macros-that-work]: https://www.researchgate.net/publication/220997237_Macros_That_Work
